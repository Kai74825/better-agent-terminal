import { app, BrowserWindow, ipcMain, dialog, shell, Menu, powerMonitor, clipboard, nativeImage } from 'electron'
import path from 'path'
import * as fs from 'fs/promises'
import { PtyManager } from './pty-manager'
import { ClaudeAgentManager } from './claude-agent-manager'
import { checkForUpdates, UpdateCheckResult } from './update-checker'
import { snippetDb, CreateSnippetInput } from './snippet-db'
import { ProfileManager } from './profile-manager'
import { registerHandler, invokeHandler } from './remote/handler-registry'
import { broadcastHub } from './remote/broadcast-hub'
import { PROXIED_CHANNELS } from './remote/protocol'
import { RemoteServer } from './remote/remote-server'
import { RemoteClient } from './remote/remote-client'

// Set AppUserModelId for Windows taskbar pinning (must be before app.whenReady)
if (process.platform === 'win32') {
  app.setAppUserModelId('org.tonyq.better-agent-terminal')
}

let mainWindow: BrowserWindow | null = null
let ptyManager: PtyManager | null = null
let claudeManager: ClaudeAgentManager | null = null
let updateCheckResult: UpdateCheckResult | null = null
const profileManager = new ProfileManager()
const remoteServer = new RemoteServer()
let remoteClient: RemoteClient | null = null
const detachedWindows = new Map<string, BrowserWindow>() // workspaceId â†’ BrowserWindow

function getAllWindows(): BrowserWindow[] {
  const wins: BrowserWindow[] = []
  if (mainWindow && !mainWindow.isDestroyed()) wins.push(mainWindow)
  for (const win of detachedWindows.values()) {
    if (!win.isDestroyed()) wins.push(win)
  }
  return wins
}

const VITE_DEV_SERVER_URL = process.env['VITE_DEV_SERVER_URL']
const GITHUB_REPO_URL = 'https://github.com/tony1223/better-agent-terminal'

function buildMenu() {
  const template: Electron.MenuItemConstructorOptions[] = [
    {
      label: 'File',
      submenu: [
        { role: 'quit' }
      ]
    },
    {
      label: 'Edit',
      submenu: [
        { role: 'undo' },
        { role: 'redo' },
        { type: 'separator' },
        { role: 'cut' },
        { role: 'copy' },
        { role: 'paste' },
        { role: 'selectAll' }
      ]
    },
    {
      label: 'View',
      submenu: [
        { role: 'reload' },
        { role: 'forceReload' },
        { role: 'toggleDevTools' },
        { type: 'separator' },
        { role: 'resetZoom' },
        { role: 'zoomIn' },
        { role: 'zoomOut' },
        { type: 'separator' },
        { role: 'togglefullscreen' }
      ]
    },
    {
      label: 'Help',
      submenu: [
        {
          label: 'GitHub Repository',
          click: () => shell.openExternal(GITHUB_REPO_URL)
        },
        {
          label: 'Report Issue',
          click: () => shell.openExternal(`${GITHUB_REPO_URL}/issues`)
        },
        {
          label: 'Releases',
          click: () => shell.openExternal(`${GITHUB_REPO_URL}/releases`)
        },
        { type: 'separator' },
        {
          label: 'About',
          click: () => {
            dialog.showMessageBox(mainWindow!, {
              type: 'info',
              title: 'About Better Agent Terminal',
              message: 'Better Agent Terminal',
              detail: `Version: ${app.getVersion()}\n\nA terminal aggregator with multi-workspace support and Claude Code integration.\n\nAuthor: TonyQ`
            })
          }
        }
      ]
    }
  ]

  // Add Update menu item if update is available
  if (updateCheckResult?.hasUpdate && updateCheckResult.latestRelease) {
    template.push({
      label: 'ðŸŽ‰ Update Available!',
      submenu: [
        {
          label: `Download ${updateCheckResult.latestRelease.tagName}`,
          click: () => {
            const url = updateCheckResult!.latestRelease!.downloadUrl || updateCheckResult!.latestRelease!.htmlUrl
            shell.openExternal(url)
          }
        },
        {
          label: 'View Release Notes',
          click: () => shell.openExternal(updateCheckResult!.latestRelease!.htmlUrl)
        }
      ]
    })
  }

  const menu = Menu.buildFromTemplate(template)
  Menu.setApplicationMenu(menu)
}

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1400,
    height: 900,
    minWidth: 800,
    minHeight: 600,
    webPreferences: {
      preload: path.join(__dirname, 'preload.js'),
      nodeIntegration: false,
      contextIsolation: true
    },
    frame: true,
    titleBarStyle: 'default',
    title: 'Better Agent Terminal',
    icon: path.join(__dirname, '../assets/icon.ico')
  })

  ptyManager = new PtyManager(getAllWindows)
  claudeManager = new ClaudeAgentManager(getAllWindows)

  if (VITE_DEV_SERVER_URL) {
    mainWindow.loadURL(VITE_DEV_SERVER_URL)
    mainWindow.webContents.openDevTools()
  } else {
    mainWindow.loadFile(path.join(__dirname, '../dist/index.html'))
  }

  mainWindow.on('closed', () => {
    // Close all detached windows when main window closes
    for (const [, win] of detachedWindows) {
      if (!win.isDestroyed()) win.close()
    }
    detachedWindows.clear()
    mainWindow = null
  })
}

function cleanupAllProcesses() {
  try { remoteClient?.disconnect() } catch { /* ignore */ }
  try { remoteServer.stop() } catch { /* ignore */ }
  try { claudeManager?.killAll() } catch { /* ignore */ }
  try { claudeManager?.dispose() } catch { /* ignore */ }
  try { ptyManager?.dispose() } catch { /* ignore */ }
  remoteClient = null
  claudeManager = null
  ptyManager = null
}

app.whenReady().then(async () => {
  buildMenu()
  createWindow()

  // Listen for system resume from sleep/hibernate
  powerMonitor.on('resume', () => {
    console.log('System resumed from sleep')
    for (const win of getAllWindows()) {
      win.webContents.send('system:resume')
    }
  })

  // Check for updates after startup
  setTimeout(async () => {
    try {
      updateCheckResult = await checkForUpdates()
      if (updateCheckResult.hasUpdate) {
        // Rebuild menu to show update option
        buildMenu()
      }
    } catch (error) {
      console.error('Failed to check for updates:', error)
    }
  }, 2000)
})

app.on('before-quit', () => {
  cleanupAllProcesses()
})

app.on('window-all-closed', () => {
  cleanupAllProcesses()
  if (process.platform !== 'darwin') {
    app.quit()
    // Force exit after a short delay in case child processes keep the event loop alive
    setTimeout(() => process.exit(0), 1000)
  }
})

app.on('activate', () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})

// â”€â”€ Proxied handler registration (callable by both IPC and remote server) â”€â”€

function registerProxiedHandlers() {
  const MESSAGE_ARCHIVE_DIR = path.join(app.getPath('userData'), 'message-archives')

  // PTY
  registerHandler('pty:create', (options: unknown) => ptyManager?.create(options as import('../src/types').CreatePtyOptions))
  registerHandler('pty:write', (id: string, data: string) => ptyManager?.write(id, data))
  registerHandler('pty:resize', (id: string, cols: number, rows: number) => ptyManager?.resize(id, cols, rows))
  registerHandler('pty:kill', (id: string) => ptyManager?.kill(id))
  registerHandler('pty:restart', (id: string, cwd: string, shellPath?: string) => ptyManager?.restart(id, cwd, shellPath))
  registerHandler('pty:get-cwd', (id: string) => ptyManager?.getCwd(id))

  // Workspace persistence
  registerHandler('workspace:save', async (data: string) => {
    const configPath = path.join(app.getPath('userData'), 'workspaces.json')
    await fs.writeFile(configPath, data, 'utf-8')
    return true
  })
  registerHandler('workspace:load', async () => {
    const configPath = path.join(app.getPath('userData'), 'workspaces.json')
    try { return await fs.readFile(configPath, 'utf-8') } catch { return null }
  })

  // Settings persistence
  registerHandler('settings:save', async (data: string) => {
    const configPath = path.join(app.getPath('userData'), 'settings.json')
    await fs.writeFile(configPath, data, 'utf-8')
    return true
  })
  registerHandler('settings:load', async () => {
    const configPath = path.join(app.getPath('userData'), 'settings.json')
    try { return await fs.readFile(configPath, 'utf-8') } catch { return null }
  })
  registerHandler('settings:get-shell-path', async (shellType: string) => {
    const fsSync = await import('fs')
    if (process.platform === 'darwin' || process.platform === 'linux') {
      if (shellType === 'auto') return process.env.SHELL || '/bin/zsh'
      if (shellType === 'zsh') return '/bin/zsh'
      if (shellType === 'bash') {
        if (fsSync.existsSync('/opt/homebrew/bin/bash')) return '/opt/homebrew/bin/bash'
        if (fsSync.existsSync('/usr/local/bin/bash')) return '/usr/local/bin/bash'
        return '/bin/bash'
      }
      if (shellType === 'sh') return '/bin/sh'
      if (shellType === 'pwsh' || shellType === 'powershell' || shellType === 'cmd') return process.env.SHELL || '/bin/zsh'
      return shellType
    }
    if (shellType === 'auto' || shellType === 'pwsh') {
      const pwshPaths = [
        'C:\\Program Files\\PowerShell\\7\\pwsh.exe',
        'C:\\Program Files (x86)\\PowerShell\\7\\pwsh.exe',
        process.env.LOCALAPPDATA + '\\Microsoft\\WindowsApps\\pwsh.exe'
      ]
      for (const p of pwshPaths) { if (fsSync.existsSync(p)) return p }
      if (shellType === 'pwsh') return 'pwsh.exe'
    }
    if (shellType === 'auto' || shellType === 'powershell') return 'powershell.exe'
    if (shellType === 'cmd') return 'cmd.exe'
    return shellType
  })

  // Claude Agent SDK
  registerHandler('claude:start-session', (sessionId: string, options: { cwd: string; prompt?: string }) => claudeManager?.startSession(sessionId, options))
  registerHandler('claude:send-message', (sessionId: string, prompt: string, images?: string[]) => claudeManager?.sendMessage(sessionId, prompt, images))
  registerHandler('claude:stop-session', (sessionId: string) => claudeManager?.stopSession(sessionId))
  registerHandler('claude:set-permission-mode', (sessionId: string, mode: string) => claudeManager?.setPermissionMode(sessionId, mode as import('@anthropic-ai/claude-agent-sdk').PermissionMode))
  registerHandler('claude:set-model', (sessionId: string, model: string) => claudeManager?.setModel(sessionId, model))
  registerHandler('claude:set-max-thinking-tokens', (sessionId: string, tokens: number | null) => claudeManager?.setMaxThinkingTokens(sessionId, tokens))
  registerHandler('claude:get-supported-models', (sessionId: string) => claudeManager?.getSupportedModels(sessionId))
  registerHandler('claude:resolve-permission', (sessionId: string, toolUseId: string, result: { behavior: string; updatedInput?: Record<string, unknown>; message?: string }) => claudeManager?.resolvePermission(sessionId, toolUseId, result))
  registerHandler('claude:resolve-ask-user', (sessionId: string, toolUseId: string, answers: Record<string, string>) => claudeManager?.resolveAskUser(sessionId, toolUseId, answers))
  registerHandler('claude:list-sessions', (cwd: string) => claudeManager?.listSessions(cwd))
  registerHandler('claude:resume-session', (sessionId: string, sdkSessionId: string, cwd: string) => claudeManager?.resumeSession(sessionId, sdkSessionId, cwd))
  registerHandler('claude:rest-session', (sessionId: string) => claudeManager?.restSession(sessionId))
  registerHandler('claude:wake-session', (sessionId: string) => claudeManager?.wakeSession(sessionId))
  registerHandler('claude:is-resting', (sessionId: string) => claudeManager?.isResting(sessionId) ?? false)

  // Message archiving
  registerHandler('claude:archive-messages', async (sessionId: string, messages: unknown[]) => {
    await fs.mkdir(MESSAGE_ARCHIVE_DIR, { recursive: true })
    const filePath = path.join(MESSAGE_ARCHIVE_DIR, `${sessionId}.jsonl`)
    const lines = messages.map(m => JSON.stringify(m)).join('\n') + '\n'
    await fs.appendFile(filePath, lines, 'utf-8')
    return true
  })
  registerHandler('claude:load-archived', async (sessionId: string, offset: number, limit: number) => {
    const filePath = path.join(MESSAGE_ARCHIVE_DIR, `${sessionId}.jsonl`)
    try {
      const content = await fs.readFile(filePath, 'utf-8')
      const lines = content.trim().split('\n').filter(Boolean)
      const total = lines.length
      const end = total - offset
      const start = Math.max(0, end - limit)
      if (end <= 0) return { messages: [], total, hasMore: false }
      const slice = lines.slice(start, end)
      return { messages: slice.map(l => JSON.parse(l)), total, hasMore: start > 0 }
    } catch { return { messages: [], total: 0, hasMore: false } }
  })
  registerHandler('claude:clear-archive', async (sessionId: string) => {
    const filePath = path.join(MESSAGE_ARCHIVE_DIR, `${sessionId}.jsonl`)
    try { await fs.unlink(filePath) } catch { /* ignore */ }
    return true
  })

  // Git
  registerHandler('git:get-github-url', async (folderPath: string) => {
    try {
      const { execSync } = await import('child_process')
      const remote = execSync('git remote get-url origin', { cwd: folderPath, encoding: 'utf-8', timeout: 3000 }).trim()
      const sshMatch = remote.match(/^git@github\.com:(.+?)(?:\.git)?$/)
      if (sshMatch) return `https://github.com/${sshMatch[1]}`
      const httpsMatch = remote.match(/^https?:\/\/github\.com\/(.+?)(?:\.git)?$/)
      if (httpsMatch) return `https://github.com/${httpsMatch[1]}`
      return null
    } catch { return null }
  })
  registerHandler('git:branch', async (cwd: string) => {
    try {
      const { execSync } = await import('child_process')
      return execSync('git rev-parse --abbrev-ref HEAD', { cwd, encoding: 'utf-8', timeout: 3000 }).trim() || null
    } catch { return null }
  })
  registerHandler('git:log', async (cwd: string, count: number = 50) => {
    try {
      const { execSync } = await import('child_process')
      const raw = execSync(`git log --pretty=format:"%H||%an||%ai||%s" -n ${count}`, { cwd, encoding: 'utf-8', timeout: 5000 }).trim()
      if (!raw) return []
      return raw.split('\n').map(line => {
        const parts = line.split('||')
        return { hash: parts[0], author: parts[1], date: parts[2], message: parts.slice(3).join('||') }
      })
    } catch { return [] }
  })
  registerHandler('git:diff', async (cwd: string, commitHash?: string, filePath?: string) => {
    try {
      const { execSync } = await import('child_process')
      let cmd = (commitHash && commitHash !== 'working') ? `git diff ${commitHash}~1..${commitHash}` : 'git diff HEAD'
      if (filePath) cmd += ` -- "${filePath}"`
      return execSync(cmd, { cwd, encoding: 'utf-8', timeout: 10000, maxBuffer: 1024 * 1024 * 5 })
    } catch { return '' }
  })
  registerHandler('git:diff-files', async (cwd: string, commitHash?: string) => {
    try {
      const { execSync } = await import('child_process')
      const cmd = (commitHash && commitHash !== 'working') ? `git diff --name-status ${commitHash}~1..${commitHash}` : 'git diff --name-status HEAD'
      const raw = execSync(cmd, { cwd, encoding: 'utf-8', timeout: 5000 })
      if (!raw.trim()) return []
      return raw.trim().split('\n').map(line => {
        const tab = line.indexOf('\t')
        return { status: tab > 0 ? line.substring(0, tab).trim() : line.charAt(0), file: tab > 0 ? line.substring(tab + 1) : line.substring(2) }
      })
    } catch { return [] }
  })
  registerHandler('git:status', async (cwd: string) => {
    try {
      const { execSync } = await import('child_process')
      const raw = execSync('git status --porcelain -uall', { cwd, encoding: 'utf-8', timeout: 5000 })
      if (!raw.trim()) return []
      return raw.trim().split('\n').map(line => ({ status: line.substring(0, 2).trim(), file: line.substring(3) }))
    } catch { return [] }
  })

  // File system
  registerHandler('fs:readdir', async (dirPath: string) => {
    const IGNORED = new Set(['.git', 'node_modules', '.next', 'dist', 'dist-electron', '.cache', '__pycache__', '.DS_Store'])
    try {
      const entries = await fs.readdir(dirPath, { withFileTypes: true })
      return entries
        .filter(e => !IGNORED.has(e.name))
        .sort((a, b) => { if (a.isDirectory() !== b.isDirectory()) return a.isDirectory() ? -1 : 1; return a.name.localeCompare(b.name) })
        .map(e => ({ name: e.name, path: path.join(dirPath, e.name), isDirectory: e.isDirectory() }))
    } catch { return [] }
  })
  registerHandler('fs:readFile', async (filePath: string) => {
    try {
      const stat = await fs.stat(filePath)
      if (stat.size > 512 * 1024) return { error: 'File too large', size: stat.size }
      const content = await fs.readFile(filePath, 'utf-8')
      return { content }
    } catch { return { error: 'Failed to read file' } }
  })
  registerHandler('fs:search', async (dirPath: string, query: string) => {
    const IGNORED = new Set(['.git', 'node_modules', '.next', 'dist', 'dist-electron', '.cache', '__pycache__', '.DS_Store', 'release'])
    const results: { name: string; path: string; isDirectory: boolean }[] = []
    const lowerQuery = query.toLowerCase()
    async function walk(dir: string, depth: number) {
      if (depth > 8 || results.length >= 100) return
      try {
        const entries = await fs.readdir(dir, { withFileTypes: true })
        for (const e of entries) {
          if (results.length >= 100) return
          if (IGNORED.has(e.name)) continue
          const fullPath = path.join(dir, e.name)
          if (e.name.toLowerCase().includes(lowerQuery)) results.push({ name: e.name, path: fullPath, isDirectory: e.isDirectory() })
          if (e.isDirectory()) await walk(fullPath, depth + 1)
        }
      } catch { /* skip */ }
    }
    await walk(dirPath, 0)
    return results.sort((a, b) => { if (a.isDirectory !== b.isDirectory) return a.isDirectory ? -1 : 1; return a.name.localeCompare(b.name) })
  })

  // Snippets
  registerHandler('snippet:getAll', () => snippetDb.getAll())
  registerHandler('snippet:getById', (id: number) => snippetDb.getById(id))
  registerHandler('snippet:create', (input: CreateSnippetInput) => snippetDb.create(input))
  registerHandler('snippet:update', (id: number, updates: Partial<CreateSnippetInput>) => snippetDb.update(id, updates))
  registerHandler('snippet:delete', (id: number) => snippetDb.delete(id))
  registerHandler('snippet:toggleFavorite', (id: number) => snippetDb.toggleFavorite(id))
  registerHandler('snippet:search', (query: string) => snippetDb.search(query))
  registerHandler('snippet:getCategories', () => snippetDb.getCategories())
  registerHandler('snippet:getFavorites', () => snippetDb.getFavorites())
}

// â”€â”€ Bind all proxied handlers to ipcMain â”€â”€

function bindProxiedHandlersToIpc() {
  for (const channel of PROXIED_CHANNELS) {
    ipcMain.handle(channel, async (_event, ...args: unknown[]) => {
      // If remote client is connected, route to remote server
      if (remoteClient?.isConnected) {
        return remoteClient.invoke(channel, args)
      }
      return invokeHandler(channel, args)
    })
  }
}

// â”€â”€ Local-only IPC handlers (not proxied) â”€â”€

function registerLocalHandlers() {
  ipcMain.handle('dialog:select-folder', async () => {
    const result = await dialog.showOpenDialog(mainWindow!, { properties: ['openDirectory'] })
    return result.canceled ? null : result.filePaths[0]
  })

  ipcMain.handle('dialog:select-images', async () => {
    const result = await dialog.showOpenDialog(mainWindow!, {
      filters: [{ name: 'Images', extensions: ['png', 'jpg', 'jpeg', 'gif', 'webp'] }],
      properties: ['openFile', 'multiSelections'],
    })
    return result.canceled ? [] : result.filePaths
  })

  ipcMain.handle('shell:open-external', async (_event, url: string) => { await shell.openExternal(url) })
  ipcMain.handle('shell:open-path', async (_event, folderPath: string) => { await shell.openPath(folderPath) })

  ipcMain.handle('update:check', async () => {
    try { return await checkForUpdates() }
    catch (error) { console.error('Failed to check for updates:', error); return { hasUpdate: false, currentVersion: app.getVersion(), latestRelease: null } }
  })
  ipcMain.handle('update:get-version', () => app.getVersion())

  ipcMain.handle('clipboard:saveImage', async () => {
    const image = clipboard.readImage()
    if (image.isEmpty()) return null
    const os = await import('os')
    const filePath = path.join(os.tmpdir(), `bat-clipboard-${Date.now()}.png`)
    await fs.writeFile(filePath, image.toPNG())
    return filePath
  })
  ipcMain.handle('clipboard:writeImage', async (_event, filePath: string) => {
    const image = nativeImage.createFromPath(filePath)
    if (image.isEmpty()) return false
    clipboard.writeImage(image)
    return true
  })

  ipcMain.handle('image:read-as-data-url', async (_event, filePath: string) => {
    const ext = path.extname(filePath).toLowerCase()
    const mimeMap: Record<string, string> = { '.png': 'image/png', '.jpg': 'image/jpeg', '.jpeg': 'image/jpeg', '.gif': 'image/gif', '.webp': 'image/webp' }
    const mime = mimeMap[ext] || 'image/png'
    const data = await fs.readFile(filePath)
    return `data:${mime};base64,${data.toString('base64')}`
  })

  // Remote server handlers (always local)
  ipcMain.handle('remote:start-server', async (_event, port?: number, token?: string) => {
    try { return remoteServer.start(port, token) }
    catch (err: unknown) { return { error: err instanceof Error ? err.message : String(err) } }
  })
  ipcMain.handle('remote:stop-server', async () => {
    remoteServer.stop()
    return true
  })
  ipcMain.handle('remote:server-status', async () => ({
    running: remoteServer.isRunning,
    port: remoteServer.port,
    clients: remoteServer.connectedClients
  }))

  // Remote client handlers
  ipcMain.handle('remote:connect', async (_event, host: string, port: number, token: string, label?: string) => {
    try {
      remoteClient = new RemoteClient(getAllWindows)
      const ok = await remoteClient.connect(host, port, token, label)
      if (!ok) {
        remoteClient = null
        return { error: 'Connection failed (auth rejected or unreachable)' }
      }
      return { connected: true }
    } catch (err: unknown) {
      remoteClient = null
      return { error: err instanceof Error ? err.message : String(err) }
    }
  })
  ipcMain.handle('remote:disconnect', async () => {
    remoteClient?.disconnect()
    remoteClient = null
    return true
  })
  ipcMain.handle('remote:client-status', async () => ({
    connected: remoteClient?.isConnected ?? false,
    info: remoteClient?.connectionInfo ?? null
  }))

  // Profile handlers (always local)
  ipcMain.handle('profile:list', async () => profileManager.list())
  ipcMain.handle('profile:create', async (_event, name: string, options?: { type?: 'local' | 'remote'; remoteHost?: string; remotePort?: number; remoteToken?: string }) => profileManager.create(name, options))
  ipcMain.handle('profile:save', async (_event, profileId: string) => profileManager.save(profileId))
  ipcMain.handle('profile:load', async (_event, profileId: string) => profileManager.load(profileId))
  ipcMain.handle('profile:delete', async (_event, profileId: string) => profileManager.delete(profileId))
  ipcMain.handle('profile:rename', async (_event, profileId: string, newName: string) => profileManager.rename(profileId, newName))
  ipcMain.handle('profile:duplicate', async (_event, profileId: string, newName: string) => profileManager.duplicate(profileId, newName))
  ipcMain.handle('profile:get', async (_event, profileId: string) => profileManager.getProfile(profileId))
  ipcMain.handle('profile:set-active', async (_event, profileId: string) => profileManager.setActiveProfileId(profileId))
  ipcMain.handle('profile:get-active-id', async () => profileManager.getActiveProfileId())

  // Workspace detach/reattach (local window management)
  ipcMain.handle('workspace:detach', async (_event, workspaceId: string) => {
    if (detachedWindows.has(workspaceId)) {
      const existing = detachedWindows.get(workspaceId)!
      if (!existing.isDestroyed()) existing.focus()
      return true
    }
    const detachedWin = new BrowserWindow({
      width: 900, height: 700, minWidth: 600, minHeight: 400,
      webPreferences: { preload: path.join(__dirname, 'preload.js'), nodeIntegration: false, contextIsolation: true },
      frame: true, titleBarStyle: 'default', icon: path.join(__dirname, '../assets/icon.ico')
    })
    detachedWindows.set(workspaceId, detachedWin)
    const urlParam = `?detached=${encodeURIComponent(workspaceId)}`
    if (VITE_DEV_SERVER_URL) { detachedWin.loadURL(VITE_DEV_SERVER_URL + urlParam) }
    else { detachedWin.loadFile(path.join(__dirname, '../dist/index.html'), { search: urlParam }) }
    detachedWin.on('closed', () => {
      detachedWindows.delete(workspaceId)
      if (mainWindow && !mainWindow.isDestroyed()) mainWindow.webContents.send('workspace:reattached', workspaceId)
    })
    if (mainWindow && !mainWindow.isDestroyed()) mainWindow.webContents.send('workspace:detached', workspaceId)
    return true
  })

  ipcMain.handle('workspace:reattach', async (_event, workspaceId: string) => {
    const win = detachedWindows.get(workspaceId)
    if (win && !win.isDestroyed()) win.close()
    detachedWindows.delete(workspaceId)
    return true
  })
}

// â”€â”€ Initialize all IPC â”€â”€
registerProxiedHandlers()
bindProxiedHandlersToIpc()
registerLocalHandlers()
