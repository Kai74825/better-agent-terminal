import { useState, useEffect, useRef, useCallback, useMemo } from 'react'
import type { ClaudeMessage, ClaudeToolCall } from '../types/claude-agent'
import { isToolCall } from '../types/claude-agent'
import { settingsStore } from '../stores/settings-store'
import { workspaceStore } from '../stores/workspace-store'
import { LinkedText } from './PathLinker'

interface SessionMeta {
  model?: string
  sdkSessionId?: string
  cwd?: string
  totalCost: number
  inputTokens: number
  outputTokens: number
  durationMs: number
  numTurns: number
  contextWindow: number
  permissionMode?: string
}

interface ModelInfo {
  value: string
  displayName: string
  description: string
}

interface PendingPermission {
  toolUseId: string
  toolName: string
  input: Record<string, unknown>
  suggestions?: unknown[]
}

interface AskUserQuestion {
  question: string
  header: string
  options: Array<{ label: string; description: string }>
  multiSelect: boolean
}

interface PendingAskUser {
  toolUseId: string
  questions: AskUserQuestion[]
}

interface SessionSummary {
  sdkSessionId: string
  timestamp: number
  preview: string
  messageCount: number
}

interface ClaudeAgentPanelProps {
  sessionId: string
  cwd: string
  isActive: boolean
  workspaceId?: string
  savedSdkSessionId?: string
}

interface AttachedImage {
  path: string
  dataUrl: string
}

type MessageItem = ClaudeMessage | ClaudeToolCall

// Track sessions that have been started to prevent duplicate calls across StrictMode remounts
const startedSessions = new Set<string>()

export function ClaudeAgentPanel({ sessionId, cwd, isActive, workspaceId, savedSdkSessionId }: Readonly<ClaudeAgentPanelProps>) {
  const [messages, setMessages] = useState<MessageItem[]>([])
  const inputValueRef = useRef('')
  const [isStreaming, setIsStreaming] = useState(false)
  const [streamingText, setStreamingText] = useState('')
  const [streamingThinking, setStreamingThinking] = useState('')
  const [showThinking, setShowThinking] = useState(false)
  const [expandedTools, setExpandedTools] = useState<Set<string>>(new Set())
  const [autoExpandThinking, setAutoExpandThinking] = useState(false)
  const [sessionMeta, setSessionMeta] = useState<SessionMeta | null>(null)
  const [permissionMode, setPermissionMode] = useState<string>(() =>
    settingsStore.getSettings().allowBypassPermissions ? 'bypassPermissions' : 'default'
  )
  const [currentModel, setCurrentModel] = useState<string>('')
  // const [effortLevel, setEffortLevel] = useState<string>('medium') // hidden until SDK supports per-model effort
  const [availableModels, setAvailableModels] = useState<ModelInfo[]>([])
  const [pendingPermission, setPendingPermission] = useState<PendingPermission | null>(null)
  const [permissionFocus, setPermissionFocus] = useState(0) // 0=Yes, 1=Yes always, 2=No, 3=custom text
  const [permissionCustomText, setPermissionCustomText] = useState('')
  const [pendingQuestion, setPendingQuestion] = useState<PendingAskUser | null>(null)
  const [askAnswers, setAskAnswers] = useState<Record<string, string>>({})
  const [askOtherText, setAskOtherText] = useState<Record<string, string>>({})
  const [attachedImages, setAttachedImages] = useState<AttachedImage[]>([])
  const [isDragOver, setIsDragOver] = useState(false)
  const [gitBranch, setGitBranch] = useState<string | null>(null)
  const [showResumeList, setShowResumeList] = useState(false)
  const [resumeSessions, setResumeSessions] = useState<SessionSummary[]>([])
  const [resumeLoading, setResumeLoading] = useState(false)
  const [showModelList, setShowModelList] = useState(false)
  const historyLoadedRef = useRef(false)
  const sessionStartedRef = useRef(false)
  const inputHistoryRef = useRef<string[]>([])
  const inputHistoryIndexRef = useRef(-1)
  const inputDraftRef = useRef('')
  const initialModeAppliedRef = useRef(false)
  const messagesEndRef = useRef<HTMLDivElement>(null)
  const messagesContainerRef = useRef<HTMLDivElement>(null)
  const textareaRef = useRef<HTMLTextAreaElement>(null)
  const permissionCardRef = useRef<HTMLDivElement>(null)
  const [userScrolledUp, setUserScrolledUp] = useState(false)
  const isNearBottomRef = useRef(true)
  const [aboveViewportUserMsgIds, setAboveViewportUserMsgIds] = useState<Set<string>>(new Set())
  const userMsgRefsMap = useRef<Map<string, HTMLDivElement>>(new Map())
  const observerRef = useRef<IntersectionObserver | null>(null)

  // Check if scrolled near bottom (within 80px)
  const checkIfNearBottom = useCallback(() => {
    const el = messagesContainerRef.current
    if (!el) return true
    return el.scrollHeight - el.scrollTop - el.clientHeight < 80
  }, [])

  // Auto-scroll to bottom — use instant scroll to avoid layout thrashing with rapid updates
  const scrollToBottom = useCallback(() => {
    messagesEndRef.current?.scrollIntoView({ behavior: 'instant' as ScrollBehavior })
    setUserScrolledUp(false)
    isNearBottomRef.current = true
  }, [])

  // Handle user scroll events on messages container
  const handleMessagesScroll = useCallback(() => {
    const nearBottom = checkIfNearBottom()
    isNearBottomRef.current = nearBottom
    setUserScrolledUp(!nearBottom)
  }, [checkIfNearBottom])

  // Only auto-scroll if user hasn't scrolled up
  useEffect(() => {
    if (isNearBottomRef.current) {
      messagesEndRef.current?.scrollIntoView({ behavior: 'instant' as ScrollBehavior })
    }
  }, [messages, streamingText, streamingThinking])

  // Compute pinned user messages (last 3 user messages that scrolled above viewport)
  // Show regardless of scroll position — the point is to always show context
  const pinnedMessages = useMemo(() => {
    if (aboveViewportUserMsgIds.size === 0) return []
    const userMsgs = messages.filter(m => !isToolCall(m) && (m as ClaudeMessage).role === 'user') as ClaudeMessage[]
    return userMsgs.filter(m => aboveViewportUserMsgIds.has(m.id)).slice(-3)
  }, [messages, aboveViewportUserMsgIds])

  // IntersectionObserver to detect user messages scrolled above viewport
  useEffect(() => {
    const container = messagesContainerRef.current
    if (!container) return

    observerRef.current?.disconnect()
    const obs = new IntersectionObserver(
      (entries) => {
        setAboveViewportUserMsgIds(prev => {
          const next = new Set(prev)
          let changed = false
          for (const entry of entries) {
            const msgId = (entry.target as HTMLElement).dataset.userMsgId
            if (!msgId) continue
            if (!entry.isIntersecting && entry.boundingClientRect.bottom < (entry.rootBounds?.top ?? 0)) {
              if (!next.has(msgId)) { next.add(msgId); changed = true }
            } else if (entry.isIntersecting) {
              if (next.has(msgId)) { next.delete(msgId); changed = true }
            }
          }
          return changed ? next : prev
        })
      },
      { root: container, threshold: 0 }
    )
    observerRef.current = obs

    // Observe all user message elements
    userMsgRefsMap.current.forEach((el) => obs.observe(el))

    return () => obs.disconnect()
  }, [messages])

  // Callback ref to register user message elements for IntersectionObserver
  const setUserMsgRef = useCallback((id: string, el: HTMLDivElement | null) => {
    if (el) {
      userMsgRefsMap.current.set(id, el)
      observerRef.current?.observe(el)
    } else {
      const prev = userMsgRefsMap.current.get(id)
      if (prev) observerRef.current?.unobserve(prev)
      userMsgRefsMap.current.delete(id)
    }
  }, [])

  // Scroll to a specific user message when clicking a pinned item
  const scrollToUserMsg = useCallback((msgId: string) => {
    const el = userMsgRefsMap.current.get(msgId)
    if (el) el.scrollIntoView({ behavior: 'smooth', block: 'center' })
  }, [])

  // Sync pending action state to workspace store for breathing light indicator
  useEffect(() => {
    const hasPending = !!(pendingPermission || pendingQuestion)
    workspaceStore.setTerminalPendingAction(sessionId, hasPending)
  }, [sessionId, pendingPermission, pendingQuestion])

  // Subscribe to IPC events
  useEffect(() => {
    const api = window.electronAPI.claude

    const unsubs = [
      api.onMessage((sid: string, msg: unknown) => {
        if (sid !== sessionId) return
        workspaceStore.updateTerminalActivity(sessionId)
        const message = msg as ClaudeMessage
        // On restart, sys-init message arrives again — reset messages
        // But skip reset if history will be loaded (resume flow)
        if (message.id === `sys-init-${sessionId}`) {
          if (!historyLoadedRef.current) {
            setMessages([message])
          }
          setStreamingText('')
          setStreamingThinking('')
          setIsStreaming(false)
          setSessionMeta(null)
          return
        }
        // Deduplicate by id; attach streaming thinking if backend didn't provide it
        setStreamingThinking(prevThinking => {
          const finalMsg = (!message.thinking && prevThinking && message.role === 'assistant')
            ? { ...message, thinking: prevThinking }
            : message
          setMessages(prev => {
            if (prev.some(m => m.id === finalMsg.id)) return prev
            return [...prev, finalMsg]
          })
          return ''
        })
        setStreamingText('')
      }),

      api.onToolUse((sid: string, tool: unknown) => {
        if (sid !== sessionId) return
        workspaceStore.updateTerminalActivity(sessionId)
        const toolCall = tool as ClaudeToolCall
        setMessages(prev => {
          if (prev.some(m => 'toolName' in m && m.id === toolCall.id)) return prev
          return [...prev, toolCall]
        })
      }),

      api.onToolResult((sid: string, result: unknown) => {
        if (sid !== sessionId) return
        workspaceStore.updateTerminalActivity(sessionId)
        const { id, ...updates } = result as { id: string; status: string; result?: string }
        setMessages(prev => prev.map(m => {
          if ('toolName' in m && m.id === id) {
            return { ...m, ...updates } as ClaudeToolCall
          }
          return m
        }))
      }),

      api.onResult((sid: string, _result: unknown) => {
        if (sid !== sessionId) return
        setIsStreaming(false)
        setStreamingText('')
        setStreamingThinking('')
      }),

      api.onError((sid: string, error: string) => {
        if (sid !== sessionId) return
        setMessages(prev => [...prev, {
          id: `err-${Date.now()}`,
          sessionId: sid,
          role: 'system' as const,
          content: `Error: ${error}`,
          timestamp: Date.now(),
        }])
        setIsStreaming(false)
      }),

      api.onStream((sid: string, data: unknown) => {
        if (sid !== sessionId) return
        workspaceStore.updateTerminalActivity(sessionId)
        const d = data as { text?: string; thinking?: string }
        if (d.text) setStreamingText(prev => prev + d.text)
        if (d.thinking) setStreamingThinking(prev => prev + d.thinking)
      }),

      api.onStatus((sid: string, meta: unknown) => {
        if (sid !== sessionId) return
        const m = meta as SessionMeta
        setSessionMeta(m)
        if (m.model) setCurrentModel(m.model)
        // On first status, apply preferred permission mode if bypass is enabled in settings
        if (!initialModeAppliedRef.current) {
          initialModeAppliedRef.current = true
          if (settingsStore.getSettings().allowBypassPermissions) {
            window.electronAPI.claude.setPermissionMode(sessionId, 'bypassPermissions')
          } else if (m.permissionMode) {
            setPermissionMode(m.permissionMode)
          }
        } else if (m.permissionMode) {
          setPermissionMode(m.permissionMode)
        }
        // Persist SDK session ID for auto-resume
        if (m.sdkSessionId && workspaceId) {
          workspaceStore.setLastSdkSessionId(workspaceId, m.sdkSessionId)
        }
      }),

      api.onPermissionRequest((sid: string, data: unknown) => {
        if (sid !== sessionId) return
        setPendingPermission(data as PendingPermission)
        setPermissionFocus(0)
        setPermissionCustomText('')
      }),

      api.onAskUser((sid: string, data: unknown) => {
        if (sid !== sessionId) return
        setPendingQuestion(data as PendingAskUser)
        setAskAnswers({})
        setAskOtherText({})
      }),

      api.onHistory((sid: string, items: unknown[]) => {
        if (sid !== sessionId) return
        historyLoadedRef.current = true
        // Replace messages with the full history batch
        setMessages(items as MessageItem[])
        setStreamingText('')
        setStreamingThinking('')
        // Reset the flag after a tick so future restarts work normally
        setTimeout(() => { historyLoadedRef.current = false }, 100)
      }),

      api.onModeChange((sid: string, mode: string) => {
        if (sid !== sessionId) return
        // When exiting plan mode, restore to bypass if setting is enabled
        if (mode === 'default' && settingsStore.getSettings().allowBypassPermissions) {
          setPermissionMode('bypassPermissions')
          window.electronAPI.claude.setPermissionMode(sessionId, 'bypassPermissions')
        } else {
          setPermissionMode(mode)
        }
      }),
    ]

    return () => {
      unsubs.forEach(unsub => unsub())
    }
  }, [sessionId])

  // Start session on mount (guarded against StrictMode double-mount)
  // If savedSdkSessionId exists, auto-resume that session
  useEffect(() => {
    if (!sessionStartedRef.current && !startedSessions.has(sessionId)) {
      sessionStartedRef.current = true
      startedSessions.add(sessionId)
      if (savedSdkSessionId) {
        window.electronAPI.claude.startSession(sessionId, { cwd, sdkSessionId: savedSdkSessionId })
      } else {
        window.electronAPI.claude.startSession(sessionId, { cwd })
      }
    }
    return () => {
      // Don't remove from startedSessions on unmount — StrictMode will remount
    }
  }, [sessionId, cwd, savedSdkSessionId])

  // Fetch supported models once session metadata arrives
  useEffect(() => {
    if (sessionMeta?.sdkSessionId && availableModels.length === 0) {
      window.electronAPI.claude.getSupportedModels(sessionId).then((models: ModelInfo[]) => {
        if (models && models.length > 0) {
          setAvailableModels(models)
        }
      }).catch(() => {})
    }
  }, [sessionId, sessionMeta?.sdkSessionId, availableModels.length])

  // Fetch git branch on mount and when cwd changes
  useEffect(() => {
    window.electronAPI.git.getBranch(cwd).then(branch => setGitBranch(branch)).catch(() => setGitBranch(null))
  }, [cwd])

  // Focus textarea when active
  useEffect(() => {
    if (isActive) {
      textareaRef.current?.focus()
    }
  }, [isActive])

  const handleModelSelect = useCallback(async (modelValue: string) => {
    setShowModelList(false)
    setCurrentModel(modelValue)
    await window.electronAPI.claude.setModel(sessionId, modelValue)
  }, [sessionId])

  const handleResumeSelect = useCallback(async (sdkSessionId: string) => {
    setShowResumeList(false)
    setResumeSessions([])
    setStreamingText('')
    setStreamingThinking('')
    setIsStreaming(false)
    // Reset the started guard so the new session can start
    startedSessions.delete(sessionId)
    sessionStartedRef.current = false
    // Mark that history will be loaded — prevents sys-init from wiping messages
    historyLoadedRef.current = true
    await window.electronAPI.claude.resumeSession(sessionId, sdkSessionId, cwd)
    if (workspaceId) {
      workspaceStore.setLastSdkSessionId(workspaceId, sdkSessionId)
    }
  }, [sessionId, cwd, workspaceId])

  const clearInput = useCallback(() => {
    inputValueRef.current = ''
    if (textareaRef.current) textareaRef.current.value = ''
  }, [])

  const setInputValue = useCallback((val: string) => {
    inputValueRef.current = val
    if (textareaRef.current) textareaRef.current.value = val
  }, [])

  const handleSend = useCallback(async () => {
    const trimmed = inputValueRef.current.trim()
    if (!trimmed) return

    // Save to input history
    inputHistoryRef.current.push(trimmed)
    inputHistoryIndexRef.current = -1
    inputDraftRef.current = ''

    // Intercept /resume command (only when not streaming)
    if (!isStreaming && trimmed === '/resume') {
      clearInput()
      setResumeLoading(true)
      setShowResumeList(true)
      try {
        const sessions = await window.electronAPI.claude.listSessions(cwd)
        setResumeSessions(sessions || [])
      } catch {
        setResumeSessions([])
      } finally {
        setResumeLoading(false)
      }
      return
    }

    // Intercept /model command
    if (trimmed === '/model') {
      clearInput()
      setShowModelList(true)
      return
    }

    const imagePaths = attachedImages.map(i => i.path)
    clearInput()
    setAttachedImages([])
    if (!isStreaming) {
      setIsStreaming(true)
      setStreamingText('')
      setStreamingThinking('')
    }

    // Add user message locally
    const imageNote = imagePaths.length > 0
      ? `\n[${imagePaths.length} image${imagePaths.length > 1 ? 's' : ''} attached]`
      : ''
    setMessages(prev => [...prev, {
      id: `user-${Date.now()}`,
      sessionId,
      role: 'user' as const,
      content: trimmed + imageNote,
      timestamp: Date.now(),
    }])

    await window.electronAPI.claude.sendMessage(sessionId, trimmed, imagePaths.length > 0 ? imagePaths : undefined)
  }, [isStreaming, sessionId, attachedImages, clearInput])

  const handleStop = useCallback(() => {
    if (!isStreaming) return
    window.electronAPI.claude.stopSession(sessionId)
    setIsStreaming(false)
    setStreamingText('')
    setStreamingThinking('')
    setPendingPermission(null)
    setMessages(prev => {
      // Mark any running tool calls as interrupted (red dot)
      const updated = prev.map(m => {
        if ('toolName' in m && (m as ClaudeToolCall).status === 'running') {
          return { ...m, status: 'error', denied: true } as ClaudeToolCall
        }
        return m
      })
      return [...updated, {
        id: `sys-stop-${Date.now()}`,
        sessionId,
        role: 'system' as const,
        content: 'Interrupted by user. You can continue typing.',
        timestamp: Date.now(),
      }]
    })
    // Focus textarea so user can type immediately
    textareaRef.current?.focus()
  }, [sessionId, isStreaming])

  const permissionModes = ['default', 'acceptEdits', 'bypassPermissions', 'plan'] as const
  const permissionModeLabels: Record<string, string> = {
    default: '\u270F Ask before edits',
    acceptEdits: '\u270F Auto-accept edits',
    bypassPermissions: '\u26A0 Bypass permissions',
    plan: '\uD83D\uDCCB Plan mode',
  }

  const handlePermissionModeCycle = useCallback(async () => {
    const idx = permissionModes.indexOf(permissionMode as typeof permissionModes[number])
    const nextMode = permissionModes[(idx + 1) % permissionModes.length]
    if (nextMode === 'bypassPermissions' && !settingsStore.getSettings().allowBypassPermissions) {
      if (!window.confirm('Warning: bypassPermissions allows all tool calls without confirmation. Continue?')) {
        return
      }
    }
    setPermissionMode(nextMode)
    await window.electronAPI.claude.setPermissionMode(sessionId, nextMode)
  }, [sessionId, permissionMode])

  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (e.key === 'Tab' && e.shiftKey) {
      e.preventDefault()
      handlePermissionModeCycle()
      return
    }
    if (e.key === 'ArrowUp' && !e.shiftKey) {
      const history = inputHistoryRef.current
      if (history.length === 0) return
      e.preventDefault()
      if (inputHistoryIndexRef.current === -1) {
        inputDraftRef.current = inputValueRef.current
        inputHistoryIndexRef.current = history.length - 1
      } else if (inputHistoryIndexRef.current > 0) {
        inputHistoryIndexRef.current--
      }
      setInputValue(history[inputHistoryIndexRef.current])
      return
    }
    if (e.key === 'ArrowDown' && !e.shiftKey) {
      if (inputHistoryIndexRef.current === -1) return
      e.preventDefault()
      const history = inputHistoryRef.current
      if (inputHistoryIndexRef.current < history.length - 1) {
        inputHistoryIndexRef.current++
        setInputValue(history[inputHistoryIndexRef.current])
      } else {
        inputHistoryIndexRef.current = -1
        setInputValue(inputDraftRef.current)
      }
      return
    }
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault()
      handleSend()
    }
  }, [handleSend, handlePermissionModeCycle, setInputValue])

  const handleModelCycle = useCallback(async () => {
    if (availableModels.length === 0) return
    const idx = availableModels.findIndex(m => m.value === currentModel)
    const next = availableModels[(idx + 1) % availableModels.length]
    setCurrentModel(next.value)
    await window.electronAPI.claude.setModel(sessionId, next.value)
  }, [sessionId, currentModel, availableModels])

  // Effort control hidden until SDK supports per-model effort metadata
  // const effortLevels = ['low', 'medium', 'high'] as const
  // const handleEffortCycle = useCallback(async () => { ... }, [sessionId, effortLevel])

  const PERMISSION_OPTION_COUNT = 4 // 0=Yes, 1=Yes always, 2=No, 3=custom text

  const handlePermissionSelect = useCallback((index?: number) => {
    if (!pendingPermission) return
    const choice = index ?? permissionFocus
    if (choice === 0) {
      // Yes — allow once
      window.electronAPI.claude.resolvePermission(sessionId, pendingPermission.toolUseId, {
        behavior: 'allow',
        updatedInput: pendingPermission.input,
      })
      setPendingPermission(null)
    } else if (choice === 1) {
      // Yes, always for this session
      window.electronAPI.claude.resolvePermission(sessionId, pendingPermission.toolUseId, {
        behavior: 'allow',
        updatedInput: pendingPermission.input,
      })
      setPendingPermission(null)
    } else if (choice === 2) {
      // No — use the same message as VS Code CLI
      const toolId = pendingPermission.toolUseId
      setMessages(prev => prev.map(m => {
        if ('toolName' in m && m.id === toolId) {
          return { ...m, denied: true } as ClaudeToolCall
        }
        return m
      }))
      window.electronAPI.claude.resolvePermission(sessionId, pendingPermission.toolUseId, {
        behavior: 'deny',
        message: "The user doesn't want to proceed with this tool use. The tool use was rejected (eg. if it was a file edit, the new_string was NOT written to the file). STOP what you are doing and wait for the user to tell you how to proceed.",
      })
      setPendingPermission(null)
    } else if (choice === 3) {
      // Custom text — deny with reason message
      const msg = permissionCustomText.trim()
      if (!msg) return // don't submit empty
      // Update the tool call in messages to show the deny reason
      const toolId = pendingPermission.toolUseId
      setMessages(prev => prev.map(m => {
        if ('toolName' in m && m.id === toolId) {
          return { ...m, denyReason: msg, denied: true } as ClaudeToolCall
        }
        return m
      }))
      window.electronAPI.claude.resolvePermission(sessionId, pendingPermission.toolUseId, {
        behavior: 'deny',
        message: msg,
      })
      setPendingPermission(null)
      setPermissionCustomText('')
    }
  }, [sessionId, pendingPermission, permissionFocus, permissionCustomText])

  // Auto-focus permission card when it appears or when panel becomes active again
  useEffect(() => {
    if (isActive && pendingPermission && permissionCardRef.current) {
      permissionCardRef.current.focus()
    }
  }, [isActive, pendingPermission])

  const permissionCustomRef = useRef<HTMLInputElement>(null)

  // Auto-focus custom text input when option 3 is selected
  useEffect(() => {
    if (permissionFocus === 3 && permissionCustomRef.current) {
      permissionCustomRef.current.focus()
    }
  }, [permissionFocus])

  // Global keyboard listener
  useEffect(() => {
    if (!isActive) return
    const handleGlobalKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Escape') {
        if (showModelList) {
          e.preventDefault()
          setShowModelList(false)
          return
        }
        if (showResumeList) {
          e.preventDefault()
          setShowResumeList(false)
          setResumeSessions([])
          return
        }
        if (pendingPermission) {
          e.preventDefault()
          handlePermissionSelect(2) // Deny
          return
        }
        if (isStreaming) {
          e.preventDefault()
          handleStop()
          return
        }
      }
      if (pendingPermission) {
        // If typing in custom text input, only handle Enter/Escape/ArrowUp
        if (permissionFocus === 3) {
          if (e.key === 'Enter') {
            e.preventDefault()
            handlePermissionSelect(3)
            return
          }
          if (e.key === 'ArrowUp') {
            e.preventDefault()
            setPermissionFocus(2)
            return
          }
          return // let other keys go to the input
        }
        // Number key shortcuts
        if (e.key === '1') { e.preventDefault(); handlePermissionSelect(0); return }
        if (e.key === '2') { e.preventDefault(); handlePermissionSelect(1); return }
        if (e.key === '3') { e.preventDefault(); handlePermissionSelect(2); return }
        // Arrow up/down navigation
        if (e.key === 'ArrowUp') {
          e.preventDefault()
          setPermissionFocus(prev => Math.max(0, prev - 1))
          return
        }
        if (e.key === 'ArrowDown' || e.key === 'Tab') {
          e.preventDefault()
          setPermissionFocus(prev => Math.min(PERMISSION_OPTION_COUNT - 1, prev + 1))
          return
        }
        if (e.key === 'Enter') {
          e.preventDefault()
          handlePermissionSelect()
          return
        }
        // Legacy shortcuts
        if (e.key === 'y' || e.key === 'Y') { e.preventDefault(); handlePermissionSelect(0); return }
        if (e.key === 'n' || e.key === 'N') { e.preventDefault(); handlePermissionSelect(2); return }
      }
    }
    window.addEventListener('keydown', handleGlobalKeyDown)
    return () => window.removeEventListener('keydown', handleGlobalKeyDown)
  }, [isActive, isStreaming, handleStop, pendingPermission, permissionFocus, handlePermissionSelect, showResumeList, showModelList])

  const handleAskUserSubmit = useCallback(() => {
    if (!pendingQuestion) return
    // Merge selected answers with "Other" text inputs
    const finalAnswers = { ...askAnswers }
    for (const [key, text] of Object.entries(askOtherText)) {
      if (text.trim()) {
        finalAnswers[key] = text.trim()
      }
    }
    window.electronAPI.claude.resolveAskUser(sessionId, pendingQuestion.toolUseId, finalAnswers)
    setPendingQuestion(null)
    setAskAnswers({})
    setAskOtherText({})
  }, [sessionId, pendingQuestion, askAnswers, askOtherText])

  const MAX_IMAGES = 5

  const addImageByPath = useCallback(async (filePath: string) => {
    setAttachedImages(prev => {
      if (prev.length >= MAX_IMAGES) return prev
      if (prev.some(img => img.path === filePath)) return prev
      return prev // will be updated after async
    })
    // Check limit and dedup before reading
    const current = attachedImages
    if (current.length >= MAX_IMAGES || current.some(img => img.path === filePath)) return
    try {
      const dataUrl = await window.electronAPI.image.readAsDataUrl(filePath)
      setAttachedImages(prev => {
        if (prev.length >= MAX_IMAGES) return prev
        if (prev.some(img => img.path === filePath)) return prev
        return [...prev, { path: filePath, dataUrl }]
      })
    } catch (err) {
      console.error('Failed to read image:', err)
    }
  }, [attachedImages])

  const handlePaste = useCallback(async (e: React.ClipboardEvent) => {
    const items = e.clipboardData?.items
    if (!items) return
    for (const item of items) {
      if (item.type.startsWith('image/')) {
        e.preventDefault()
        const filePath = await window.electronAPI.clipboard.saveImage()
        if (filePath) {
          await addImageByPath(filePath)
        }
        return
      }
    }
  }, [addImageByPath])

  const handleDragOver = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    setIsDragOver(true)
  }, [])

  const handleDragLeave = useCallback((e: React.DragEvent) => {
    e.preventDefault()
    setIsDragOver(false)
  }, [])

  const handleDrop = useCallback(async (e: React.DragEvent) => {
    e.preventDefault()
    setIsDragOver(false)
    const files = e.dataTransfer.files
    for (const file of files) {
      if (file.type.startsWith('image/') && file.path) {
        await addImageByPath(file.path)
      }
    }
  }, [addImageByPath])

  const handleSelectImages = useCallback(async () => {
    const paths = await window.electronAPI.dialog.selectImages()
    for (const p of paths) {
      await addImageByPath(p)
    }
  }, [addImageByPath])

  const removeImage = useCallback((filePath: string) => {
    setAttachedImages(prev => prev.filter(img => img.path !== filePath))
  }, [])

  const toggleTool = useCallback((id: string, isThinking?: boolean) => {
    setExpandedTools(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
        // Once the user expands any thinking block, auto-expand all future ones
        if (isThinking) setAutoExpandThinking(true)
      }
      return next
    })
  }, [])

  const toolInputSummary = (_toolName: string, input: Record<string, unknown>): string => {
    // Show a compact one-line summary of tool input
    if (input.command) return String(input.command).slice(0, 80)
    if (input.file_path) return String(input.file_path)
    if (input.pattern) return String(input.pattern)
    if (input.query) return String(input.query).slice(0, 80)
    if (input.url) return String(input.url).slice(0, 80)
    if (input.prompt) return String(input.prompt).slice(0, 80)
    const keys = Object.keys(input)
    if (keys.length === 0) return ''
    return keys.slice(0, 2).map(k => `${k}: ${String(input[k]).slice(0, 40)}`).join(', ')
  }

  // Extract main content string for the IN block display
  const toolInputContent = (input: Record<string, unknown>): string => {
    if (input.command) return String(input.command)
    if (input.file_path) return String(input.file_path)
    if (input.pattern) return String(input.pattern)
    if (input.query) return String(input.query)
    if (input.url) return String(input.url)
    if (input.prompt) return String(input.prompt)
    return JSON.stringify(input, null, 2)
  }

  const toolDescription = (input: Record<string, unknown>): string | null => {
    if (input.description) return String(input.description)
    return null
  }

  const [copiedId, setCopiedId] = useState<string | null>(null)
  const handleCopyBlock = useCallback((text: string, blockId: string) => {
    navigator.clipboard.writeText(text).then(() => {
      setCopiedId(blockId)
      setTimeout(() => setCopiedId(null), 1500)
    })
  }, [])

  // Extract <system-reminder> blocks from text
  const splitSystemReminders = (text: string): { content: string; reminders: string[] } => {
    const reminders: string[] = []
    const content = text.replace(/<system-reminder>\s*([\s\S]*?)\s*<\/system-reminder>/g, (_match, inner) => {
      reminders.push(inner.trim())
      return ''
    }).trim()
    return { content, reminders }
  }

  const renderTodoChecklist = (input: Record<string, unknown>) => {
    const todos = input.todos as Array<{ content: string; status: string; activeForm?: string }> | undefined
    if (!todos || !Array.isArray(todos)) return null
    return (
      <div className="claude-todo-checklist">
        {todos.map((todo, i) => (
          <div key={i} className={`claude-todo-item claude-todo-${todo.status}`}>
            <span className="claude-todo-check">
              {todo.status === 'completed' ? '\u2611' : todo.status === 'in_progress' ? '\u25B6' : '\u2610'}
            </span>
            <span className="claude-todo-text">{todo.content}</span>
          </div>
        ))}
      </div>
    )
  }

  const formatTimestamp = (ts: number): string => {
    const d = new Date(ts)
    const now = new Date()
    const isToday = d.toDateString() === now.toDateString()
    const time = d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
    if (isToday) return time
    // Not today — show full date + time
    return d.toLocaleString([], { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' })
  }

  const formatFullTimestamp = (ts: number): string => {
    return new Date(ts).toLocaleString([], { year: 'numeric', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit', second: '2-digit' })
  }

  const shouldShowTimeDivider = (current: MessageItem, prevItem: MessageItem | undefined): boolean => {
    if (!prevItem) return false
    const curTs = current.timestamp || 0
    const prevTs = prevItem.timestamp || 0
    if (!curTs || !prevTs) return false
    // Show divider if gap > 30 minutes
    return (curTs - prevTs) > 30 * 60 * 1000
  }

  const renderMessage = (item: MessageItem, index: number) => {
    if (isToolCall(item)) {
      // TodoWrite: render as a visual checklist
      if (item.toolName === 'TodoWrite') {
        return (
          <div key={item.id || index} className="tl-item">
            <div className={`tl-dot ${item.status === 'running' ? 'dot-running' : 'dot-success'}`} />
            <div className="tl-content">
              <div className="claude-tool-header" onClick={() => toggleTool(item.id)}>
                <span className="claude-tool-name">Checklist</span>
              </div>
              {renderTodoChecklist(item.input)}
            </div>
          </div>
        )
      }

      const dotClass = item.denied ? 'dot-denied' : item.status === 'running' ? 'dot-running' : item.status === 'completed' ? 'dot-success' : 'dot-error'
      const desc = toolDescription(item.input)

      // Task tool: custom structured renderer
      if (item.toolName === 'Task') {
        const prompt = String(item.input.prompt || '')
        const isPromptExpanded = expandedTools.has(`task-prompt-${item.id}`)
        const isResultExpanded = expandedTools.has(`task-result-${item.id}`)
        const promptLines = prompt.split('\n')
        const isLongPrompt = promptLines.length > 3 || prompt.length > 200
        const truncatedPrompt = isLongPrompt
          ? promptLines.slice(0, 3).join('\n').slice(0, 200) + '...'
          : prompt
        const model = item.input.model ? String(item.input.model) : null
        const maxTurns = item.input.max_turns ? String(item.input.max_turns) : null
        const runBg = item.input.run_in_background ? true : false
        const resultRaw = item.result ? (typeof item.result === 'string' ? item.result : String(item.result)) : ''
        const { content: resultText, reminders: resultReminders } = splitSystemReminders(resultRaw)
        return (
          <div key={item.id || index} className="tl-item">
            <div className={`tl-dot ${dotClass}`} />
            <div className="tl-content">
              <div className="claude-tool-header" onClick={() => toggleTool(item.id)}>
                <span className="claude-tool-name">Task</span>
                {item.input.subagent_type && <span className="claude-tool-badge">{String(item.input.subagent_type)}</span>}
                {desc && <span className="claude-tool-desc">{desc}</span>}
                {item.timestamp > 0 && <span className="claude-tool-time" title={formatFullTimestamp(item.timestamp)}>{formatTimestamp(item.timestamp)}</span>}
              </div>
              {(model || maxTurns || runBg) && (
                <div className="claude-task-meta">
                  {model && <span className="claude-task-tag">model: {model}</span>}
                  {maxTurns && <span className="claude-task-tag">max_turns: {maxTurns}</span>}
                  {runBg && <span className="claude-task-tag">background</span>}
                </div>
              )}
              <div className="claude-task-prompt">
                <div className="claude-task-section-header" onClick={() => toggleTool(`task-prompt-${item.id}`)}>
                  <span className="claude-task-section-label">PROMPT</span>
                  <span className={`claude-tool-chevron ${isPromptExpanded ? 'expanded' : ''}`}>&#9654;</span>
                </div>
                <pre className="claude-task-prompt-text">{isPromptExpanded || !isLongPrompt ? prompt : truncatedPrompt}</pre>
              </div>
              {resultText && (
                <div className="claude-task-result">
                  <div className="claude-task-section-header" onClick={() => toggleTool(`task-result-${item.id}`)}>
                    <span className="claude-task-section-label">RESULT</span>
                    <span className={`claude-tool-chevron ${isResultExpanded ? 'expanded' : ''}`}>&#9654;</span>
                  </div>
                  {isResultExpanded && (
                    <div className="claude-task-result-text"><LinkedText text={resultText} /></div>
                  )}
                </div>
              )}
              {resultReminders.length > 0 && (
                <div className="claude-task-result">
                  <div className="claude-task-section-header claude-system-reminder-row" onClick={() => toggleTool(`reminder-${item.id}`)}>
                    <span className="claude-task-section-label claude-reminder-label">SYS</span>
                    <span className={`claude-tool-chevron ${expandedTools.has(`reminder-${item.id}`) ? 'expanded' : ''}`}>&#9654;</span>
                  </div>
                  {expandedTools.has(`reminder-${item.id}`) && (
                    <div className="claude-task-result-text" style={{ opacity: 0.6 }}>{resultReminders.join('\n\n')}</div>
                  )}
                </div>
              )}
              {expandedTools.has(item.id) && (
                <div className="claude-tool-body">
                  <div className="claude-tool-input">
                    <div className="claude-tool-label">Full Input</div>
                    <pre>{JSON.stringify(item.input, null, 2)}</pre>
                  </div>
                </div>
              )}
            </div>
          </div>
        )
      }

      // Edit tool: show diff view
      if (item.toolName === 'Edit' && item.input.old_string !== undefined) {
        const filePath = String(item.input.file_path || '')
        const oldStr = String(item.input.old_string || '')
        const newStr = String(item.input.new_string || '')
        const isDiffExpanded = expandedTools.has(`diff-${item.id}`)
        const oldLines = oldStr.split('\n')
        const newLines = newStr.split('\n')
        const totalLines = oldLines.length + newLines.length
        const isLongDiff = totalLines > 12
        const resultRaw = item.result ? (typeof item.result === 'string' ? item.result : String(item.result)) : ''
        const { content: resultText } = splitSystemReminders(resultRaw)
        return (
          <div key={item.id || index} className="tl-item">
            <div className={`tl-dot ${dotClass}`} />
            <div className="tl-content">
              <div className="claude-tool-header" onClick={() => toggleTool(item.id)}>
                <span className="claude-tool-name">Edit</span>
                <span className="claude-tool-desc"><LinkedText text={filePath} /></span>
                {item.timestamp > 0 && <span className="claude-tool-time" title={formatFullTimestamp(item.timestamp)}>{formatTimestamp(item.timestamp)}</span>}
              </div>
              <div className="claude-diff-block">
                {(isDiffExpanded || !isLongDiff ? oldLines : oldLines.slice(0, 3)).map((line, i) => (
                  <div key={`o${i}`} className="claude-diff-line claude-diff-del">
                    <span className="claude-diff-sign">-</span>
                    <span className="claude-diff-text">{line}</span>
                  </div>
                ))}
                {(isDiffExpanded || !isLongDiff ? newLines : newLines.slice(0, 3)).map((line, i) => (
                  <div key={`n${i}`} className="claude-diff-line claude-diff-add">
                    <span className="claude-diff-sign">+</span>
                    <span className="claude-diff-text">{line}</span>
                  </div>
                ))}
                {isLongDiff && (
                  <div className="claude-diff-toggle" onClick={() => toggleTool(`diff-${item.id}`)}>
                    {isDiffExpanded ? 'Collapse' : `Show all ${totalLines} lines...`}
                  </div>
                )}
              </div>
              {resultText && (
                <div className="claude-tool-blocks">
                  <div className="claude-tool-row">
                    <span className="claude-tool-row-label">OUT</span>
                    <span className="claude-tool-row-content"><LinkedText text={resultText} /></span>
                  </div>
                </div>
              )}
              {expandedTools.has(item.id) && (
                <div className="claude-tool-body">
                  <div className="claude-tool-input">
                    <div className="claude-tool-label">Full Input</div>
                    <pre>{JSON.stringify(item.input, null, 2)}</pre>
                  </div>
                </div>
              )}
            </div>
          </div>
        )
      }

      // Write tool: show content preview
      if (item.toolName === 'Write' && item.input.content !== undefined) {
        const filePath = String(item.input.file_path || '')
        const content = String(item.input.content || '')
        const isContentExpanded = expandedTools.has(`write-${item.id}`)
        const contentLines = content.split('\n')
        const isLong = contentLines.length > 8
        const resultRaw = item.result ? (typeof item.result === 'string' ? item.result : String(item.result)) : ''
        const { content: resultText } = splitSystemReminders(resultRaw)
        return (
          <div key={item.id || index} className="tl-item">
            <div className={`tl-dot ${dotClass}`} />
            <div className="tl-content">
              <div className="claude-tool-header" onClick={() => toggleTool(item.id)}>
                <span className="claude-tool-name">Write</span>
                <span className="claude-tool-desc"><LinkedText text={filePath} /></span>
                {item.timestamp > 0 && <span className="claude-tool-time" title={formatFullTimestamp(item.timestamp)}>{formatTimestamp(item.timestamp)}</span>}
              </div>
              <div className="claude-diff-block">
                {(isContentExpanded || !isLong ? contentLines : contentLines.slice(0, 8)).map((line, i) => (
                  <div key={i} className="claude-diff-line claude-diff-add">
                    <span className="claude-diff-sign">+</span>
                    <span className="claude-diff-text">{line}</span>
                  </div>
                ))}
                {isLong && (
                  <div className="claude-diff-toggle" onClick={() => toggleTool(`write-${item.id}`)}>
                    {isContentExpanded ? 'Collapse' : `Show all ${contentLines.length} lines...`}
                  </div>
                )}
              </div>
              {resultText && (
                <div className="claude-tool-blocks">
                  <div className="claude-tool-row">
                    <span className="claude-tool-row-label">OUT</span>
                    <span className="claude-tool-row-content"><LinkedText text={resultText} /></span>
                  </div>
                </div>
              )}
              {expandedTools.has(item.id) && (
                <div className="claude-tool-body">
                  <div className="claude-tool-input">
                    <div className="claude-tool-label">Full Input</div>
                    <pre>{JSON.stringify(item.input, null, 2)}</pre>
                  </div>
                </div>
              )}
            </div>
          </div>
        )
      }

      const inContent = toolInputContent(item.input)
      const inBlockId = `in-${item.id}`
      const outBlockId = `out-${item.id}`
      return (
        <div key={item.id || index} className="tl-item">
          <div className={`tl-dot ${dotClass}`} />
          <div className="tl-content">
            <div className="claude-tool-header" onClick={() => toggleTool(item.id)}>
              <span className="claude-tool-name">{item.toolName}</span>
              {desc && <span className="claude-tool-desc">{desc}</span>}
              {!desc && <span className="claude-tool-summary">{toolInputSummary(item.toolName, item.input)}</span>}
              {item.timestamp > 0 && <span className="claude-tool-time" title={formatFullTimestamp(item.timestamp)}>{formatTimestamp(item.timestamp)}</span>}
            </div>
            {item.denyReason && (
              <div className="claude-tool-reason">Reason: {item.denyReason}</div>
            )}
            <div className="claude-tool-blocks">
              <div
                className="claude-tool-row"
                onClick={() => handleCopyBlock(inContent, inBlockId)}
                title="Click to copy"
              >
                <span className="claude-tool-row-label">IN</span>
                <span className="claude-tool-row-content"><LinkedText text={inContent} /></span>
                <span className={`claude-tool-row-copy ${copiedId === inBlockId ? 'copied' : ''}`}>
                  {copiedId === inBlockId ? '✓' : '⧉'}
                </span>
              </div>
              {item.result && (() => {
                const raw = typeof item.result === 'string' ? item.result : String(item.result)
                const { content: outText, reminders } = splitSystemReminders(raw)
                return (
                  <>
                    {outText && (
                      <div
                        className="claude-tool-row"
                        onClick={() => handleCopyBlock(outText, outBlockId)}
                        title="Click to copy"
                      >
                        <span className="claude-tool-row-label">OUT</span>
                        <span className="claude-tool-row-content"><LinkedText text={outText} /></span>
                        <span className={`claude-tool-row-copy ${copiedId === outBlockId ? 'copied' : ''}`}>
                          {copiedId === outBlockId ? '✓' : '⧉'}
                        </span>
                      </div>
                    )}
                    {reminders.length > 0 && (
                      <div
                        className="claude-tool-row claude-system-reminder-row"
                        onClick={() => toggleTool(`reminder-${item.id}`)}
                      >
                        <span className="claude-tool-row-label claude-reminder-label">SYS</span>
                        <span className="claude-tool-row-content">
                          {expandedTools.has(`reminder-${item.id}`)
                            ? reminders.join('\n\n')
                            : `system-reminder (${reminders.length})`
                          }
                        </span>
                        <span className={`claude-tool-chevron ${expandedTools.has(`reminder-${item.id}`) ? 'expanded' : ''}`}>&#9654;</span>
                      </div>
                    )}
                  </>
                )
              })()}
            </div>
            {item.denied && (
              <div className="claude-tool-interrupted">Tool interrupted</div>
            )}
            {expandedTools.has(item.id) && (
              <div className="claude-tool-body">
                <div className="claude-tool-input">
                  <div className="claude-tool-label">Full Input</div>
                  <pre>{JSON.stringify(item.input, null, 2)}</pre>
                </div>
              </div>
            )}
          </div>
        </div>
      )
    }

    const msg = item as ClaudeMessage
    if (msg.role === 'system') {
      return (
        <div key={msg.id || index} className="tl-item tl-item-system">
          <div className="tl-dot dot-system" />
          <div className="tl-content claude-message-system">
            {msg.content}
            {msg.timestamp > 0 && (
              <span className="claude-msg-time" title={formatFullTimestamp(msg.timestamp)}>{formatTimestamp(msg.timestamp)}</span>
            )}
          </div>
        </div>
      )
    }
    if (msg.role === 'user') {
      return (
        <div
          key={msg.id || index}
          className="tl-item tl-item-user"
          data-user-msg-id={msg.id}
          ref={(el) => setUserMsgRef(msg.id, el)}
        >
          <div className="tl-dot dot-user" />
          <div className="tl-content claude-message-user">
            {msg.content}
            {msg.timestamp > 0 && (
              <span className="claude-msg-time" title={formatFullTimestamp(msg.timestamp)}>{formatTimestamp(msg.timestamp)}</span>
            )}
          </div>
        </div>
      )
    }
    // assistant
    return (
      <div key={msg.id || index} className="tl-item">
        <div className="tl-dot dot-assistant" />
        <div className="tl-content claude-message-assistant">
          {msg.thinking && (() => {
            const isExpanded = expandedTools.has(msg.id) || (autoExpandThinking && !expandedTools.has(`${msg.id}-collapsed`))
            return (
              <div className="claude-thinking-block">
                <div
                  className="claude-thinking-toggle"
                  onClick={() => {
                    if (isExpanded && autoExpandThinking) {
                      // If auto-expanded, clicking collapses by marking it explicitly collapsed
                      setExpandedTools(prev => { const next = new Set(prev); next.add(`${msg.id}-collapsed`); return next })
                    } else {
                      toggleTool(msg.id, true)
                    }
                  }}
                >
                  <span className={`claude-tool-chevron ${isExpanded ? 'expanded' : ''}`}>&#9654;</span>
                  <span className="claude-thinking-label">Thinking</span>
                </div>
                {isExpanded && (
                  <pre className="claude-thinking-content">{msg.thinking}</pre>
                )}
              </div>
            )
          })()}
          {msg.content && <div className="claude-markdown">{msg.content}</div>}
          {msg.timestamp > 0 && (
            <span className="claude-msg-time" title={formatFullTimestamp(msg.timestamp)}>{formatTimestamp(msg.timestamp)}</span>
          )}
        </div>
      </div>
    )
  }

  return (
    <div
      className="claude-agent-panel"
      onDragOver={handleDragOver}
      onDragLeave={handleDragLeave}
      onDrop={handleDrop}
    >
      {pinnedMessages.length > 0 && (
        <div className="claude-pinned-messages">
          {pinnedMessages.map(msg => (
            <div key={msg.id} className="claude-pinned-item" onClick={() => scrollToUserMsg(msg.id)}>
              <span className="claude-pinned-dot" />
              <span className="claude-pinned-text">{msg.content}</span>
            </div>
          ))}
        </div>
      )}
      <div className="claude-messages claude-timeline" ref={messagesContainerRef} onScroll={handleMessagesScroll}>
        {messages.map((item, i) => {
          const divider = shouldShowTimeDivider(item, messages[i - 1]) ? (
            <div key={`divider-${i}`} className="claude-time-divider">
              <span>{formatTimestamp(item.timestamp || 0)}</span>
            </div>
          ) : null
          return <>{divider}{renderMessage(item, i)}</>
        })}
        {isStreaming && !streamingText && !streamingThinking && (
          <div className="tl-item">
            <div className="tl-dot dot-thinking" />
            <div className="tl-content claude-thinking">
              <span className="claude-thinking-text">Thinking</span>
              <span className="claude-thinking-dots"><span>.</span><span>.</span><span>.</span></span>
            </div>
          </div>
        )}
        {streamingThinking && (
          <div className="tl-item">
            <div className="tl-dot dot-thinking" />
            <div className="tl-content claude-thinking-block">
              <div
                className="claude-thinking-toggle"
                onClick={() => setShowThinking(prev => !prev)}
              >
                <span className={`claude-tool-chevron ${showThinking ? 'expanded' : ''}`}>&#9654;</span>
                <span className="claude-thinking-label">Thinking{isStreaming && streamingThinking && !streamingText ? '...' : ''}</span>
              </div>
              {showThinking && (
                <pre className="claude-thinking-content">{streamingThinking}</pre>
              )}
            </div>
          </div>
        )}
        {streamingText && (
          <div className="tl-item">
            <div className="tl-dot dot-assistant" />
            <div className="tl-content claude-message-assistant">
              <div className="claude-markdown">{streamingText}<span className="claude-cursor">|</span></div>
            </div>
          </div>
        )}
        <div ref={messagesEndRef} />
        {userScrolledUp && (
          <button className="scroll-to-bottom-btn" onClick={scrollToBottom} title="Scroll to bottom">
            &#x2193;
          </button>
        )}
      </div>

      {/* Permission Request Card — VS Code style vertical list */}
      {pendingPermission && (
        <div
          ref={permissionCardRef}
          tabIndex={-1}
          className={`claude-permission-card ${
            ['Bash', 'Write', 'NotebookEdit'].includes(pendingPermission.toolName) ? 'danger'
            : ['Edit', 'TaskCreate', 'TaskUpdate'].includes(pendingPermission.toolName) ? 'warning'
            : 'safe'
          }`}
        >
          <div className="claude-permission-title">
            Allow this <strong>{pendingPermission.toolName}</strong> call?
          </div>
          <div className="claude-permission-command">
            {toolInputSummary(pendingPermission.toolName, pendingPermission.input)}
          </div>
          {pendingPermission.input.description && (
            <div className="claude-permission-desc">
              {String(pendingPermission.input.description)}
            </div>
          )}
          <div className="claude-permission-options">
            <div
              className={`claude-permission-option ${permissionFocus === 0 ? 'focused' : ''}`}
              onClick={() => handlePermissionSelect(0)}
              onMouseEnter={() => setPermissionFocus(0)}
            >
              <span className="claude-permission-option-num">1</span>
              <span className="claude-permission-option-label">Yes</span>
            </div>
            <div
              className={`claude-permission-option ${permissionFocus === 1 ? 'focused' : ''}`}
              onClick={() => handlePermissionSelect(1)}
              onMouseEnter={() => setPermissionFocus(1)}
            >
              <span className="claude-permission-option-num">2</span>
              <span className="claude-permission-option-label">Yes, don't ask again for this session</span>
            </div>
            <div
              className={`claude-permission-option ${permissionFocus === 2 ? 'focused' : ''}`}
              onClick={() => handlePermissionSelect(2)}
              onMouseEnter={() => setPermissionFocus(2)}
            >
              <span className="claude-permission-option-num">3</span>
              <span className="claude-permission-option-label">No</span>
            </div>
            <div
              className={`claude-permission-option custom ${permissionFocus === 3 ? 'focused' : ''}`}
              onClick={() => { setPermissionFocus(3); permissionCustomRef.current?.focus() }}
              onMouseEnter={() => setPermissionFocus(3)}
            >
              <input
                ref={permissionCustomRef}
                className="claude-permission-custom-input"
                type="text"
                placeholder="Tell Claude what to do instead"
                value={permissionCustomText}
                onChange={e => setPermissionCustomText(e.target.value)}
                onFocus={() => setPermissionFocus(3)}
              />
            </div>
          </div>
          <div className="claude-permission-hint">Esc to cancel</div>
        </div>
      )}

      {/* AskUserQuestion Card */}
      {pendingQuestion && (
        <div className="claude-ask-card">
          {pendingQuestion.questions.map((q, qi) => (
            <div key={qi} className="claude-ask-question">
              <div className="claude-ask-header">{q.header}</div>
              <div className="claude-ask-text">{q.question}</div>
              <div className="claude-ask-options">
                {q.options.map((opt, oi) => (
                  <button
                    key={oi}
                    className={`claude-ask-option ${askAnswers[String(qi)] === opt.label ? 'selected' : ''}`}
                    onClick={() => setAskAnswers(prev => ({ ...prev, [String(qi)]: opt.label }))}
                    title={opt.description}
                  >
                    {opt.label}
                  </button>
                ))}
              </div>
              <div className="claude-ask-other">
                <input
                  type="text"
                  placeholder="Other..."
                  value={askOtherText[String(qi)] || ''}
                  onChange={e => setAskOtherText(prev => ({ ...prev, [String(qi)]: e.target.value }))}
                />
              </div>
            </div>
          ))}
          <div className="claude-ask-actions">
            <button className="claude-permission-btn allow" onClick={handleAskUserSubmit}>Submit</button>
          </div>
        </div>
      )}

      {/* Resume Session List */}
      {showResumeList && (
        <div className="claude-resume-card">
          <div className="claude-permission-title">Resume a previous session</div>
          {resumeLoading ? (
            <div className="claude-resume-empty">Loading sessions...</div>
          ) : resumeSessions.length === 0 ? (
            <div className="claude-resume-empty">No sessions found</div>
          ) : (
            <div className="claude-resume-list">
              {resumeSessions.map(s => (
                <div
                  key={s.sdkSessionId}
                  className="claude-resume-item"
                  onClick={() => handleResumeSelect(s.sdkSessionId)}
                >
                  <div className="claude-resume-item-header">
                    <span className="claude-resume-item-id">{s.sdkSessionId.slice(0, 8)}</span>
                    <span className="claude-resume-item-time">
                      {new Date(s.timestamp).toLocaleString()}
                    </span>
                  </div>
                  <div className="claude-resume-item-preview">{s.preview}</div>
                </div>
              ))}
            </div>
          )}
          <div className="claude-permission-hint">Esc to cancel</div>
        </div>
      )}

      {/* Model Selection List */}
      {showModelList && (
        <div className="claude-resume-card">
          <div className="claude-permission-title">Select a model</div>
          {availableModels.length === 0 ? (
            <div className="claude-resume-empty">No models available</div>
          ) : (
            <div className="claude-resume-list">
              {availableModels.map(m => (
                <div
                  key={m.value}
                  className={`claude-resume-item${m.value === currentModel ? ' active' : ''}`}
                  onClick={() => handleModelSelect(m.value)}
                >
                  <div className="claude-resume-item-header">
                    <span className="claude-resume-item-id">{m.displayName}</span>
                  </div>
                  <div className="claude-resume-item-preview">{m.description}</div>
                </div>
              ))}
            </div>
          )}
          <div className="claude-permission-hint">Esc to cancel</div>
        </div>
      )}

      {/* Input area — hidden when permission card, ask-user card, or resume/model list is visible */}
      {!pendingPermission && !pendingQuestion && !showResumeList && !showModelList && (
      <div className={`claude-input-area${isDragOver ? ' drag-over' : ''}`}>
        <textarea
          ref={textareaRef}
          className="claude-input"
          defaultValue=""
          onInput={e => { inputValueRef.current = (e.target as HTMLTextAreaElement).value }}
          onKeyDown={handleKeyDown}
          onPaste={handlePaste}
          placeholder={isStreaming ? 'Press Escape to stop...' : 'Type a message... (Enter to send, Shift+Tab to switch mode)'}
          disabled={false}
          rows={1}
        />
        {attachedImages.length > 0 && (
          <div className="claude-attachments">
            {attachedImages.map(img => (
              <div key={img.path} className="claude-attachment">
                <img src={img.dataUrl} className="claude-attachment-thumb" alt="attached" />
                <button
                  className="claude-attachment-remove"
                  onClick={() => removeImage(img.path)}
                  title="Remove image"
                >
                  &times;
                </button>
              </div>
            ))}
            {attachedImages.length < MAX_IMAGES && (
              <button
                className="claude-add-image-btn"
                onClick={handleSelectImages}
                title="Add image"
              >
                +
              </button>
            )}
          </div>
        )}
        <div className="claude-input-footer">
          <div className="claude-input-controls">
            <span
              className={`claude-status-btn claude-mode-${permissionMode}`}
              onClick={handlePermissionModeCycle}
              title={`Permission: ${permissionMode} (click to cycle)`}
            >
              {permissionModeLabels[permissionMode] || permissionMode}
            </span>

            {currentModel && (
              <span
                className="claude-status-btn"
                onClick={() => setShowModelList(true)}
                title={`Model: ${currentModel} (click to select)`}
              >
                {'</>'} {currentModel}
              </span>
            )}
          </div>

          <div className="claude-input-actions">
            <span
              className="claude-status-btn"
              onClick={handleSelectImages}
              title="Attach images (max 5)"
            >
              &#128206;
            </span>
            {isStreaming ? (
              <button
                className="claude-send-btn claude-stop-btn"
                onClick={handleStop}
                title="Stop (Esc)"
              >
                ■
              </button>
            ) : (
              <button
                className="claude-send-btn"
                onClick={handleSend}
                disabled={false}
                title="Send message"
              >
                ▶
              </button>
            )}
          </div>
        </div>
      </div>
      )}

      {/* Status lines */}
      <div className="claude-statuslines">
        <div className="claude-statusline">
          {gitBranch && <span className="claude-statusline-item claude-statusline-branch">[{gitBranch}]</span>}
          {currentModel && <span className="claude-statusline-item">{currentModel}</span>}
          {sessionMeta && sessionMeta.contextWindow > 0 && (
            <span className="claude-statusline-item" title={`${(sessionMeta.inputTokens + sessionMeta.outputTokens).toLocaleString()} / ${sessionMeta.contextWindow.toLocaleString()} tokens`}>
              ctx {Math.round(((sessionMeta.inputTokens + sessionMeta.outputTokens) / sessionMeta.contextWindow) * 100)}%
            </span>
          )}
          {sessionMeta && sessionMeta.totalCost > 0 && (
            <span className="claude-statusline-item">${sessionMeta.totalCost.toFixed(4)}</span>
          )}
        </div>
        <div className="claude-statusline">
          {sessionMeta && (
            <span className="claude-statusline-item" title={`in: ${sessionMeta.inputTokens.toLocaleString()} / out: ${sessionMeta.outputTokens.toLocaleString()}`}>
              session: {(sessionMeta.inputTokens + sessionMeta.outputTokens).toLocaleString()} tok
            </span>
          )}
          {sessionMeta && sessionMeta.numTurns > 0 && (
            <span className="claude-statusline-item">{sessionMeta.numTurns} turns</span>
          )}
          {sessionMeta && sessionMeta.durationMs > 0 && (
            <span className="claude-statusline-item">{(sessionMeta.durationMs / 1000).toFixed(1)}s</span>
          )}
        </div>
      </div>
    </div>
  )
}
